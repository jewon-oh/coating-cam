'use client';

import React, { useMemo, useRef, useCallback, useEffect } from 'react';
import { Layer, Group, Rect, Transformer } from 'react-konva';
import type Konva from 'konva';
import { useAppDispatch, useAppSelector } from '@/hooks/redux';
import { useCanvas } from '@/contexts/canvas-context';
import { usePathEvents } from '@/hooks/use-path-events';
import {
    addPathGroup,
    updatePathGroups,
    removePathGroup,
    setSelectedPath,
    setSelectedSegment,
    updateSegment
} from '@/store/slices/path-slice';
import type { CustomShapeConfig } from '@/types/custom-konva-config';
import type { PathGroup, PathSegment } from '@/types/path';
import { PathCalculator } from '@/lib/gcode/path-calculator';
import { useSettings } from '@/contexts/settings-context';
import { MaskingManager } from '@/lib/gcode/mask-manager';
import { Point } from '@/lib/gcode/point';

interface PathLayerProps {
    isPanning?: boolean;
}

export function PathLayer({ isPanning = false }: PathLayerProps) {
    const layerRef = useRef<Konva.Layer>(null);
    const transformerRef = useRef<Konva.Transformer>(null);

    // Redux 상태
    const dispatch = useAppDispatch();
    const { paths, selectedPathIds } = useAppSelector((s) => s.shapes);
    const shapes = useAppSelector((s) => s.shapes.shapes) as CustomShapeConfig[];

    // 캔버스 컨텍스트
    const { stage } = useCanvas();
    const { coatingSettings } = useSettings();

    // path 생성 클래스
    const masker = new MaskingManager(coatingSettings);
    const calc = new PathCalculator(coatingSettings, masker);

    // 이벤트 훅
    const pathEvents = usePathEvents();

    const canvasScale = useMemo(() => Math.abs(stage.scaleX || 1) || 1, [stage.scaleX]);

    useEffect(() => {
        layerRef.current?.batchDraw();
    }, [selectedPathId, selectedSegmentId, pathGroups]);

    const strokeWidthFor = useCallback((base: number) => base / canvasScale, [canvasScale]);

    // Segment 선택
    const handleSegmentSelect = useCallback(
        (segmentId: string, groupId: string) => {
            dispatch(setSelectedPath(groupId));
            dispatch(setSelectedSegment(segmentId));
        },
        [dispatch]
    );

    // Transformer 핸들러
    const handleTransformStart = useCallback(() => {
        // no-op for now
    }, []);

    const handleTransform = useCallback(() => {
        if (!transformerRef.current || !selectedSegmentId) return;

        const node = transformerRef.current.nodes()[0] as Konva.Rect | undefined;
        if (!node) return;

        // Rect의 중심선을 다시 라인으로 환산하여 segment 업데이트
        // Rect: (x,y) 좌상단, width=길이, height=폭, rotation=각도
        const absTransform = node.getAbsoluteTransform();
        const topLeft = absTransform.point({ x: node.x(), y: node.y() });
        const width = node.width() * (node.scaleX() || 1);
        const height = node.height() * (node.scaleY() || 1);
        const rotationDeg = node.rotation();
        const rotationRad = (rotationDeg * Math.PI) / 180;

        // 중심선의 중점
        const cx = topLeft.x + width / 2 * Math.cos(rotationRad) - (height / 2) * Math.sin(rotationRad);
        const cy = topLeft.y + width / 2 * Math.sin(rotationRad) + (height / 2) * Math.cos(rotationRad);

        // 중심선의 양 끝점 (길이=width, 각도=rotation)
        const halfLen = width / 2;
        const dx = Math.cos(rotationRad) * halfLen;
        const dy = Math.sin(rotationRad) * halfLen;

        const startPoint = { x: cx - dx, y: cy - dy };
        const endPoint = { x: cx + dx, y: cy + dy };

        dispatch(
            updateSegment({
                segmentId: selectedSegmentId,
                updates: {
                    start: startPoint,
                    end: endPoint
                }
            })
        );
    }, [dispatch, selectedSegmentId]);

    const handleTransformEnd = useCallback(() => {
        // no-op
    }, []);

    // Transformer 설정
    const transformerConfig = useMemo(
        () => ({
            anchorStyleFunc: (anchor: Konva.Shape) => {
                anchor.cornerRadius(6);
                anchor.width(10).height(10).offsetX(5).offsetY(5);
            },
            rotateEnabled: true,
            enabledAnchors: [
                'top-left',
                'top-right',
                'bottom-left',
                'bottom-right',
                'middle-left',
                'middle-right'
            ],
            keepRatio: false,
            centeredScaling: false,
            anchorSize: 6,
            anchorStroke: '#3b82f6',
            anchorFill: '#fff',
            borderStroke: '#3b82f6',
            borderDash: [3, 3]
        }),
        []
    );

    // Transformer 노드 업데이트
    useEffect(() => {
        if (transformerRef.current && layerRef.current && selectedSegmentId) {
            const selectedNode = layerRef.current.findOne(`#${selectedSegmentId}`);
            if (selectedNode) {
                transformerRef.current.nodes([selectedNode as unknown as Konva.Node]);
                transformerRef.current.getLayer()?.batchDraw();
            } else {
                transformerRef.current.nodes([]);
            }
        } else if (transformerRef.current) {
            transformerRef.current.nodes([]);
        }
    }, [selectedSegmentId]);

    // =================== Path 생성/동기화(useEffect) ===================
    const timersRef = useRef<Map<string, number>>(new Map());
    const prevSnapRef = useRef<Map<string, string>>(new Map());

    const groupIdOf = useCallback((shapeId: string) => `${shapeId}-path`, []);

    const toSegments = useCallback(
        (pairs: { start: { x: number; y: number }; end: { x: number; y: number } }[], groupId: string): PathSegment[] => {
            return pairs.map((p, i) => ({
                id: `${groupId}-seg-${i}`,
                type: 'G1',
                start: { x: p.start.x, y: p.start.y },
                end: { x: p.end.x, y: p.end.y }
            }));
        },
        []
    );

    const shapeSnapshot = useCallback((shape: CustomShapeConfig) => {
        // Path에 영향 주는 핵심 속성만 포함
        return JSON.stringify({
            id: shape.id,
            type: shape.type,
            x: shape.x,
            y: shape.y,
            width: shape.width,
            height: shape.height,
            radius: shape.radius,
            rotation: shape.rotation,
            scaleX: shape.scaleX,
            scaleY: shape.scaleY,
            visible: shape.visible,
            coatingType: shape.coatingType,
            lineSpacing: shape.lineSpacing,
            coatingWidth: shape.coatingWidth,
            outlinePasses: shape.outlinePasses,
            outlineInterval: shape.outlineInterval,
            fillPattern: shape.fillPattern
        });
    }, []);

    useEffect(() => {
        // 1) 삭제된 Shape의 PathGroup 제거
        const currentIds = new Set(shapes.map((s) => s.id!).filter(Boolean));
        const removable = pathGroups
            .filter((g) => g.id.endsWith('-path'))
            .filter((g) => {
                const shapeId = g.id.replace(/-path$/, '');
                return !currentIds.has(shapeId);
            });
        for (const g of removable) {
            dispatch(removePathGroup(g.id));
        }

        // 2) 변경된 Shape만 선별
        const prevSnap = prevSnapRef.current;
        const currSnap = new Map<string, string>();
        const changed: CustomShapeConfig[] = [];

        for (const s of shapes) {
            if (!s.id) continue;
            if (s.type === 'image' || s.type === 'group') continue;

            const snap = shapeSnapshot(s);
            currSnap.set(s.id, snap);
            if (prevSnap.get(s.id) !== snap) {
                changed.push(s);
            }
        }

        // 3) 디바운스 스케줄
        const schedule = (shape: CustomShapeConfig, delay: number) => {
            const id = shape.id!;
            const tOld = timersRef.current.get(id);
            if (tOld) window.clearTimeout(tOld);

            const timer = window.setTimeout(async () => {
                try {
                    if (!coatingSettings) return;

                    // UI용: 상대 좌표와 변환 정보 요청
                    const result = await calc.calculateForShape(shape, {
                        relative: true,
                        includeTransform: true
                    });

                    const groupId = groupIdOf(id);
                    const segments = toSegments(result.segments ?? [], groupId);

                    const exists = pathGroups.some((g) => g.id === groupId);
                    const base = {
                        id: groupId,
                        name: `${shape.name || shape.type || 'Shape'} Path`,
                        color: '#1976d2',
                        visible: shape.visible !== false,
                        tool: 'pen',
                        speed: 1000,
                        power: 100,
                        passes: 1,
                        sourceShapeId: shape.id, // Shape 연결
                        isRelative: true, // 상대 좌표 사용
                        baseTransform: result.transform // 기본 변환 정보
                    };

                    if (exists) {
                        dispatch(
                            updatePathGroups([
                                {
                                    id: groupId,
                                    name: base.name,
                                    visible: base.visible,
                                    segments,
                                    sourceShapeId: base.sourceShapeId,
                                    isRelative: base.isRelative,
                                    baseTransform: base.baseTransform
                                }
                            ])
                        );
                    } else {
                        dispatch(
                            addPathGroup({
                                ...base,
                                segments,
                                locked: false,
                                visible: true
                            } as PathGroup)
                        );
                    }
                } catch (error) {
                    console.error('Path calculation error:', error);
                } finally {
                    timersRef.current.delete(id);
                }
            }, delay);

            timersRef.current.set(id, timer as unknown as number);
        };

        for (const s of changed) {
            const immediate = !prevSnap.has(s.id!); // 신규는 즉시 처리
            schedule(s, immediate ? 0 : 120);
        }

        // 스냅샷 저장
        prevSnapRef.current = currSnap;

        // 언마운트 시 타이머 정리
        return () => {
            timersRef.current.forEach((t) => window.clearTimeout(t));
            timersRef.current.clear();
        };
    }, [dispatch, shapes, pathGroups, shapeSnapshot, groupIdOf, toSegments, coatingSettings, calc]);

    // =================== 렌더링 ===================

    // Shape 기준 절대 좌표 계산
    const getAbsoluteCoordinates = useCallback(
        (pathGroup: PathGroup, segment: PathSegment): { start: Point; end: Point } => {
            if (!pathGroup.sourceShapeId || !pathGroup.isRelative) {
                // 절대 좌표 path (기존 방식)
                return {
                    start: segment.start,
                    end: segment.end
                };
            }

            // 연결된 shape 찾기
            const sourceShape = shapes.find((s) => s.id === pathGroup.sourceShapeId);
            if (!sourceShape) {
                return { start: segment.start, end: segment.end };
            }

            // 현재 shape의 변환 정보
            const currentTransform = {
                x: sourceShape.x ?? 0,
                y: sourceShape.y ?? 0,
                rotation: sourceShape.rotation ?? 0,
                scaleX: sourceShape.scaleX ?? 1,
                scaleY: sourceShape.scaleY ?? 1
            };

            // 기본 변환 정보 (path 생성 시점)
            const baseTransform = pathGroup.baseTransform || {
                x: 0,
                y: 0,
                rotation: 0,
                scaleX: 1,
                scaleY: 1
            };

            // 변환 차이 계산
            const deltaX = currentTransform.x - baseTransform.x;
            const deltaY = currentTransform.y - baseTransform.y;
            const deltaRotation = currentTransform.rotation - baseTransform.rotation;
            const deltaScaleX = currentTransform.scaleX / baseTransform.scaleX;
            const deltaScaleY = currentTransform.scaleY / baseTransform.scaleY;

            // 상대 좌표에 현재 shape 변환 적용
            const transformPoint = (point: Point): Point => {
                let x = point.x * deltaScaleX;
                let y = point.y * deltaScaleY;

                // 회전 적용
                if (deltaRotation !== 0) {
                    const cos = Math.cos((deltaRotation * Math.PI) / 180);
                    const sin = Math.sin((deltaRotation * Math.PI) / 180);
                    const rotatedX = x * cos - y * sin;
                    const rotatedY = x * sin + y * cos;
                    x = rotatedX;
                    y = rotatedY;
                }

                return {
                    x: x + currentTransform.x,
                    y: y + currentTransform.y
                };
            };

            return {
                start: transformPoint(segment.start),
                end: transformPoint(segment.end)
            };
        },
        [shapes]
    );

    /**
     * 선(두 점)을 중심으로 하는 직사각형(Rect) 파라미터 계산 유틸
     * - x,y: 중심 좌표
     * - offsetX/Y: 절반 크기(로컬 좌표계)로 설정하여 회전 안정화
     */
    const makeCenteredRectForSegment = useCallback(
        (start: { x: number; y: number }, end: { x: number; y: number }, thickness: number): {
            cx: number;
            cy: number;
            width: number;
            height: number;
            rotation: number;
            offsetX: number;
            offsetY: number;
        } => {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const length = Math.hypot(dx, dy) || 0.0001; // 0 보호
            const angleDeg = (Math.atan2(dy, dx) * 180) / Math.PI;

            const cx = (start.x + end.x) / 2;
            const cy = (start.y + end.y) / 2;

            const h = Math.max(thickness, 1 / canvasScale); // 최소 1px 보장

            return {
                cx,
                cy,
                width: length,
                height: h,
                rotation: angleDeg,
                offsetX: length / 2,
                offsetY: h / 2
            };
        },
        [canvasScale]
    );


    const renderSegment = useCallback(
        (segment: PathSegment, pathGroup: PathGroup, isSelected: boolean) => {
            const { start, end } = getAbsoluteCoordinates(pathGroup, segment);

            const baseColor = '#10b981';
            const moveColor = '#ef4444';
            const selectedColor = '#3b82f6';
            const strokeColor = isSelected ? selectedColor : segment.type === 'G0' ? moveColor : baseColor;
            const fillColor =
                segment.type === 'G0'
                    ? 'rgba(239,68,68,0.15)'
                    : isSelected
                        ? 'rgba(59,130,246,0.15)'
                        : 'rgba(16,185,129,0.15)';

            const coatingWidth = coatingSettings?.coatingWidth ?? 2;
            const p = makeCenteredRectForSegment(start, end, coatingWidth);

            return (
                <Rect
                    key={segment.id}
                    id={segment.id}
                    name="path-segment"
                    x={p.cx}
                    y={p.cy}
                    width={p.width}
                    height={p.height}
                    offsetX={p.offsetX}
                    offsetY={p.offsetY}
                    rotation={p.rotation}
                    fill={fillColor}
                    stroke={strokeColor}
                    strokeWidth={strokeWidthFor(isSelected ? 2 : 1)}
                    strokeScaleEnabled={false}
                    dash={segment.type === 'G0' ? [5 / canvasScale, 5 / canvasScale] : undefined}
                    onClick={(e) => {
                        e.cancelBubble = true;
                        handleSegmentSelect(segment.id, pathGroup.id);
                    }}
                    onTransformStart={handleTransformStart}
                    onTransform={handleTransform}
                    onTransformEnd={handleTransformEnd}
                    listening={!isPanning}
                    draggable={!isPanning}
                    onDragStart={pathEvents.handleDragStart}
                    onDragMove={pathEvents.handleDragMove}
                    onDragEnd={pathEvents.handleDragEnd}
                />
            );
        },
        [
            canvasScale,
            isPanning,
            handleSegmentSelect,
            strokeWidthFor,
            getAbsoluteCoordinates,
            coatingSettings,
            makeCenteredRectForSegment,
            handleTransformStart,
            handleTransform,
            handleTransformEnd,
            pathEvents.handleDragStart,
            pathEvents.handleDragMove,
            pathEvents.handleDragEnd
        ]
    );


    const renderGroup = useCallback(
        (group: PathGroup) => {
            if (group.visible === false) return null;

            return (
                <Group key={`path-group-${group.id}`} listening={!isPanning}>
                    {!group.segments?.length && (
                        <Rect
                            x={-10000}
                            y={-10000}
                            width={20000}
                            height={20000}
                            opacity={0}
                            onClick={(e) => {
                                e.cancelBubble = true;
                                pathEvents.handleSelect({
                                    ...e,
                                    target: { id: () => group.id } as any
                                } as any);
                            }}
                            listening={!isPanning}
                        />
                    )}

                    {(group.segments || []).map((seg: PathSegment) =>
                        renderSegment(seg, group, seg.id === selectedSegmentId)
                    )}
                </Group>
            );
        },
        [isPanning, pathEvents, renderSegment, selectedSegmentId]
    );

    return (
        <Layer ref={layerRef}>
            {paths.map(renderGroup)}

            {/* Transformer for selected segment (Rect) */}
            <Transformer
                ref={transformerRef}
                onTransformStart={handleTransformStart}
                onTransform={handleTransform}
                onTransformEnd={handleTransformEnd}
                visible={!!selectedPathIds && !isPanning}
                {...transformerConfig}
            />
        </Layer>
    );
}