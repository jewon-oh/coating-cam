'use client';

import React, { useRef, useCallback, useEffect, useState } from 'react';
import {Stage, Layer, Rect, Group} from 'react-konva';
import type Konva from 'konva';

// 컨텍스트 및 훅 import
import { useShapeContext, KonvaShape, RectShape, CircleShape, ImageShape } from '@/contexts/shape-context';
import { useHistory } from '@/contexts/history-context';
import { useTool } from '@/contexts/tool-context';
import { useCanvasView } from '@/hooks/use-canvas-view';
import { useCanvasInteractions } from '@/hooks/use-canvas-interactions';
import { useSettings } from '@/contexts/settings-context';
import { useGrid } from '@/hooks/use-grid';

// 분리된 도형 컴포넌트 import
import { TransformableRectangle } from '@/components/shapes/transformable-rect';
import { TransformableCircle } from '@/components/shapes/transformable-circle';
import { TransformableImage } from "@/components/shapes/transformable-image";
import { GCodeSettingsDialog } from "@/components/gcode/gcode-settings-dialog";
import { Toolbar } from "@/components/tool/toolbar";

export default function CanvasStage() {
    const { shapes, selectedShape, setSelectedShapeId, updateShape } = useShapeContext();
    const { saveHistory, undo, redo } = useHistory();
    const { tool, setTool } = useTool();
    const stageRef = useRef<Konva.Stage>(null);

    const { isGridVisible, isSnappingEnabled, gridSize } = useSettings();
    const { stage, setStage, canvasSize, handleWheel } = useCanvasView();
    const gridLayer = useGrid(stage, gridSize, canvasSize);
    const [isGCodeDialogOpen, setGCodeDialogOpen] = useState(false);

    const {
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleDelete,
        handleCopy,
        handlePaste,
        handleCut
    } = useCanvasInteractions(stageRef, setStage, setSelectedShapeId);

    const handleSelect = useCallback((id: string) => {
        if (tool === 'select') {
            setSelectedShapeId(id);
        }
    }, [tool, setSelectedShapeId]);

    const handleShapeChange = useCallback((id: string, newAttrs: Partial<KonvaShape>) => {
        updateShape(id, newAttrs, saveHistory);
    }, [updateShape, saveHistory]);

    // 키보드 이벤트 리스너
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            const target = e.target as HTMLElement;
            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') return;

            const isCtrlOrCmd = e.ctrlKey || e.metaKey;
            const selectedId = selectedShape?.id ?? null;

            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                handleDelete(selectedId);
            } else if (isCtrlOrCmd && e.key.toLowerCase() === 'c') {
                e.preventDefault();
                handleCopy(selectedId);
            } else if (isCtrlOrCmd && e.key.toLowerCase() === 'v') {
                e.preventDefault();
                handlePaste();
            } else if (isCtrlOrCmd && e.key.toLowerCase() === 'x') {
                e.preventDefault();
                handleCut(selectedId);
            } else if (isCtrlOrCmd && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undo();
            } else if (isCtrlOrCmd && e.key.toLowerCase() === 'y') {
                e.preventDefault();
                redo();
            } else if (e.metaKey && e.shiftKey && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                redo();
            }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [selectedShape, handleDelete, handleCopy, handlePaste, handleCut, undo, redo]);

    return (
        <div className="flex h-screen">
            <Toolbar onGenerateGCode={() => setGCodeDialogOpen(true)} />
            <div className="flex-1">
                <Stage
                    ref={stageRef}
                    width={canvasSize.width}
                    height={canvasSize.height}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onWheel={handleWheel}
                    x={stage.x}
                    y={stage.y}
                    scaleX={stage.scale}
                    scaleY={stage.scale}
                    listening={!isGCodeDialogOpen}
                >
                    <Layer>
                        <Rect x={-stage.x / stage.scale} y={-stage.y / stage.scale} width={canvasSize.width / stage.scale} height={canvasSize.height / stage.scale} fill="#f0f0f0" listening={false} />
                    </Layer>
                    {isGridVisible && gridLayer}
                    <Layer>
                        {shapes.map((shape) => {
                            const isSelected = shape.id === selectedShape?.id;
                            const commonProps = {
                                key: shape.id,
                                isSelected: isSelected,
                                onSelect: () => handleSelect(shape.id),
                                onChange: (newAttrs: Partial<KonvaShape>) => handleShapeChange(shape.id, newAttrs),
                                listening: tool === 'select',
                                isSnappingEnabled: isSnappingEnabled,
                                gridSize: gridSize
                            };

                            switch (shape.type) {
                                case 'rect': return <TransformableRectangle {...commonProps} shapeProps={shape as RectShape} />;
                                case 'circle': return <TransformableCircle {...commonProps} shapeProps={shape as CircleShape} />;
                                case 'image': return <TransformableImage {...commonProps} shapeProps={shape as ImageShape} />;
                                default: return null;
                            }
                        })}
                        <Group/>
                    </Layer>
                </Stage>
            </div>
            <GCodeSettingsDialog
                isOpen={isGCodeDialogOpen}
                onClose={() => setGCodeDialogOpen(false)}
            />
        </div>
    );
}
