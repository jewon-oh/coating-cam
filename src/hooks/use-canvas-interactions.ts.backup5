import React, { useRef, useCallback, useEffect } from 'react';
import type { KonvaEventObject } from 'konva/lib/Node';
import type Konva from 'konva';
import { KonvaShape, useShapeContext, ImageShape } from '@/contexts/shape-context';
import { useHistory } from '@/contexts/history-context';
import { useTool } from '@/contexts/tool-context';
import { useToolActions } from './use-tool-actions';
import { useSettings } from '@/contexts/settings-context';

export const useCanvasInteractions = (
    stageRef: React.RefObject<Konva.Stage>,
    setStage: React.Dispatch<React.SetStateAction<{ scale: number; x: number; y: number }>>,
    selectionRectRef: React.RefObject<Konva.Rect>,
    transformerRef: React.RefObject<Konva.Transformer>,
    shapeNodesRef: React.RefObject<Map<string, Konva.Shape>>
) => {
    const { shapes, addShape, updateShape, updateMultipleShapes, removeShapes, selectedShapeIds, setSelectedShapeIds } = useShapeContext();
    const { isSnappingEnabled, gridSize } = useSettings();
    const shapesRef = useRef<KonvaShape[]>();
    shapesRef.current = shapes;

    const { saveHistory } = useHistory();
    const { tool, setTool } = useTool();
    const { handleInsertImage } = useToolActions();

    const isDrawingRef = useRef(false);
    const isPanningRef = useRef(false);
    const isGroupDraggingRef = useRef(false);
    const dragInfoRef = useRef<{ startX: number, startY: number, initialPositions: Map<string, {x: number, y: number}> } | null>(null);
    const transformStartCache = useRef<Map<string, any>>(new Map());
    const clipboardRef = useRef<KonvaShape[]>([]);
    const mouseDownPos = useRef({ x: 0, y: 0 });
    const lastPointerPosition = useRef({ x: 0, y: 0 });
    const selectionStartPos = useRef({ x: 0, y: 0 });

    const snapToGrid = useCallback((value: number) => {
        if (!isSnappingEnabled) return value;
        return Math.round(value / gridSize) * gridSize;
    }, [isSnappingEnabled, gridSize]);

    // ... (useEffect for cursor style)

    const handleDelete = useCallback(() => {
        if (selectedShapeIds.length > 0) removeShapes(selectedShapeIds, (updated) => saveHistory(updated));
    }, [selectedShapeIds, removeShapes, saveHistory]);

    const handleCopy = useCallback(() => {
        if (selectedShapeIds.length > 0) clipboardRef.current = shapes.filter(s => selectedShapeIds.includes(s.id));
    }, [selectedShapeIds, shapes]);

    const handlePaste = useCallback(() => {
        if (clipboardRef.current.length === 0) return;
        const newShapes = clipboardRef.current.map(shape => ({ ...shape, id: crypto.randomUUID(), x: shape.x + 20, y: shape.y + 20 }));
        let currentShapes = shapesRef.current || [];
        newShapes.forEach(shape => addShape(shape, (updated) => { currentShapes = updated; }));
        setTimeout(() => {
            saveHistory(currentShapes);
            setSelectedShapeIds(newShapes.map(s => s.id));
        }, 100);
    }, [addShape, saveHistory, setSelectedShapeIds]);

    const handleCut = useCallback(() => {
        handleCopy();
        handleDelete();
    }, [handleCopy, handleDelete]);

    const getRelativePointerPosition = (stage: Konva.Stage) => {
        const pointer = stage.getPointerPosition();
        if (!pointer) return null;
        return stage.getAbsoluteTransform().copy().invert().point(pointer);
    };

    const handleDragStart = useCallback((e: Konva.KonvaEventObject<DragEvent>) => {
        const draggedId = e.target.id();
        if (selectedShapeIds.includes(draggedId)) {
            isGroupDraggingRef.current = true;
            const initialPositions = new Map<string, {x: number, y: number}>();
            selectedShapeIds.forEach(id => {
                const node = shapeNodesRef.current?.get(id);
                if (node) initialPositions.set(id, { x: node.x(), y: node.y() });
            });
            dragInfoRef.current = { startX: e.target.x(), startY: e.target.y(), initialPositions };
        }
    }, [selectedShapeIds, shapeNodesRef]);

    const handleDragMove = useCallback((e: Konva.KonvaEventObject<DragEvent>) => {
        if (isGroupDraggingRef.current && dragInfoRef.current) {
            const { startX, startY, initialPositions } = dragInfoRef.current;
            const dx = e.target.x() - startX;
            const dy = e.target.y() - startY;
            selectedShapeIds.forEach(id => {
                const node = shapeNodesRef.current?.get(id);
                const initialPos = initialPositions.get(id);
                if (node && initialPos) {
                    node.x(snapToGrid(initialPos.x + dx));
                    node.y(snapToGrid(initialPos.y + dy));
                }
            });
        } else {
             e.target.x(snapToGrid(e.target.x()));
             e.target.y(snapToGrid(e.target.y()));
        }
    }, [selectedShapeIds, shapeNodesRef, snapToGrid]);

    const handleDragEnd = useCallback((e: Konva.KonvaEventObject<DragEvent>) => {
        if (isGroupDraggingRef.current && dragInfoRef.current) {
            const { startX, startY, initialPositions } = dragInfoRef.current;
            const dx = e.target.x() - startX;
            const dy = e.target.y() - startY;
            const updates = selectedShapeIds.map(id => ({
                id,
                props: { x: snapToGrid((initialPositions.get(id)?.x || 0) + dx), y: snapToGrid((initialPositions.get(id)?.y || 0) + dy) }
            }));
            updateMultipleShapes(updates, (updated) => saveHistory(updated));
        } else {
            updateShape(e.target.id(), { x: snapToGrid(e.target.x()), y: snapToGrid(e.target.y()) }, (updated) => saveHistory(updated));
        }
        isGroupDraggingRef.current = false;
        dragInfoRef.current = null;
    }, [selectedShapeIds, updateMultipleShapes, updateShape, saveHistory, snapToGrid]);

    const handleTransformStart = useCallback(() => {
        const nodes = transformerRef.current?.nodes() || [];
        const cache = new Map<string, any>();
        nodes.forEach(node => {
            cache.set(node.id(), {
                width: node.width(),
                height: node.height(),
                scaleX: node.scaleX(),
                scaleY: node.scaleY(),
                crop: (node as Konva.Image).crop(),
            });
        });
        transformStartCache.current = cache;
    }, [transformerRef]);

    const handleTransform = useCallback(() => {
        const nodes = transformerRef.current?.nodes() || [];
        const anchor = transformerRef.current?.getActiveAnchor();
        const isCropping = anchor && (anchor.includes('middle') || anchor.includes('center'));

        nodes.forEach(node => {
            const imageNode = node as Konva.Image;
            const startAttrs = transformStartCache.current.get(node.id());
            if (!startAttrs) return;

            const newSize = { width: startAttrs.width * imageNode.scaleX(), height: startAttrs.height * imageNode.scaleY() };

            if (isCropping && imageNode.getType() === 'Image') {
                const { width: startWidth, height: startHeight, crop: startCrop } = startAttrs;
                const newCrop = { ...startCrop };
                let ratio;

                if (anchor.includes('left') || anchor.includes('right')) {
                    ratio = startCrop.height / startHeight;
                    const newCropWidth = newSize.width * ratio;
                    if (anchor.includes('left')) newCrop.x = startCrop.x + startCrop.width - newCropWidth;
                    newCrop.width = newCropWidth;
                } else if (anchor.includes('top') || anchor.includes('bottom')) {
                    ratio = startCrop.width / startWidth;
                    const newCropHeight = newSize.height * ratio;
                    if (anchor.includes('top')) newCrop.y = startCrop.y + startCrop.height - newCropHeight;
                    newCrop.height = newCropHeight;
                }
                
                imageNode.crop(newCrop);
            }
            
            imageNode.width(newSize.width);
            imageNode.height(newSize.height);
        });
    }, [transformerRef]);

    const handleTransformEnd = useCallback((tr: React.RefObject<Konva.Transformer>) => {
        const nodes = tr.current?.nodes() || [];
        const updates = nodes.map(node => {
            const imageNode = node as Konva.Image;
            const props: Partial<KonvaShape> = {
                x: node.x(),
                y: node.y(),
                rotation: node.rotation(),
                width: node.width() * node.scaleX(),
                height: node.height() * node.scaleY(),
                scaleX: 1,
                scaleY: 1,
            };
            if (imageNode.getType() === 'Image') {
                props.crop = imageNode.crop();
            }
            node.scaleX(1);
            node.scaleY(1);
            return { id: node.id(), props };
        });
        updateMultipleShapes(updates, (updated) => saveHistory(updated));
    }, [updateMultipleShapes, saveHistory]);

    const handleMouseDown = useCallback((e: KonvaEventObject<MouseEvent>) => {
        const stageNode = stageRef.current;
        if (!stageNode) return;

        if (e.evt.button === 2) {
            isPanningRef.current = true;
            lastPointerPosition.current = stageNode.getPointerPosition() || { x: 0, y: 0 };
            return;
        }

        const pos = getRelativePointerPosition(stageNode);
        if (!pos) return;

        const isDrawingTool = tool === 'circle' || tool === 'rectangle';
        const isSelectToolOnBackground = tool === 'select' && e.target === stageNode;

        if (isDrawingTool) {
            isDrawingRef.current = true;
            mouseDownPos.current = pos;
            const commonProps = { x: pos.x, y: pos.y, fill: 'rgba(59,130,246,0.2)', stroke: '#3b82f6', strokeWidth: 2 };
            if (tool === 'circle') addShape({ type: 'circle', radius: 0, ...commonProps });
            else addShape({ type: 'rect', width: 0, height: 0, ...commonProps });
        } else if (isSelectToolOnBackground) {
            selectionStartPos.current = pos;
            selectionRectRef.current?.visible(true);
            selectionRectRef.current?.width(0);
            selectionRectRef.current?.height(0);
        } else if (tool === 'insert-image') {
            handleInsertImage();
            setTool('select');
        }
    }, [tool, addShape, handleInsertImage, setTool, selectionRectRef, stageRef]);

    const handleMouseMove = useCallback((e: KonvaEventObject<MouseEvent>) => {
        const stageNode = stageRef.current;
        if (!stageNode) return;

        if (isPanningRef.current) {
            const newPointerPos = stageNode.getPointerPosition();
            if (!newPointerPos) return;
            const dx = newPointerPos.x - lastPointerPosition.current.x;
            const dy = newPointerPos.y - lastPointerPosition.current.y;
            setStage(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
            lastPointerPosition.current = newPointerPos;
            return;
        }

        const pos = getRelativePointerPosition(stageNode);
        if (!pos) return;

        if (selectionRectRef.current?.visible()) {
            const { x, y } = selectionStartPos.current;
            selectionRectRef.current.setAttrs({ x: Math.min(x, pos.x), y: Math.min(y, pos.y), width: Math.abs(pos.x - x), height: Math.abs(pos.y - y) });
        } else if (isDrawingRef.current) {
            const currentShapes = shapesRef.current;
            if (!currentShapes || currentShapes.length === 0) return;
            const lastShape = currentShapes[currentShapes.length - 1];
            if (!lastShape) return;
            if (lastShape.type === 'circle') {
                updateShape(lastShape.id, { radius: Math.hypot(pos.x - mouseDownPos.current.x, pos.y - mouseDownPos.current.y) });
            } else if (lastShape.type === 'rect') {
                const newWidth = pos.x - mouseDownPos.current.x;
                const newHeight = pos.y - mouseDownPos.current.y;
                updateShape(lastShape.id, { x: newWidth < 0 ? pos.x : mouseDownPos.current.x, y: newHeight < 0 ? pos.y : mouseDownPos.current.y, width: Math.abs(newWidth), height: Math.abs(newHeight) });
            }
        }
    }, [updateShape, setStage, selectionRectRef]);

    const handleMouseUp = useCallback((e: KonvaEventObject<MouseEvent>) => {
        if (isPanningRef.current && e.evt.button === 2) {
            isPanningRef.current = false;
            return;
        }

        if (selectionRectRef.current?.visible()) {
            const selBox = selectionRectRef.current.getClientRect();
            const selected = shapes.filter((shape) => Konva.Util.haveIntersection(selBox, (stageRef.current?.findOne('#' + shape.id) as Konva.Shape).getClientRect()));
            setSelectedShapeIds(selected.map((s) => s.id));
            selectionRectRef.current.visible(false);
        } else if (isDrawingRef.current) {
            isDrawingRef.current = false;
            const currentShapes = shapesRef.current;
            if (!currentShapes) return;
            const lastShape = currentShapes[currentShapes.length - 1];
            if (lastShape) {
                if ((lastShape.type === 'circle' && lastShape.radius === 0) || (lastShape.type === 'rect' && (lastShape.width === 0 || lastShape.height === 0))) {
                    removeShapes([lastShape.id]);
                } else {
                    saveHistory(currentShapes);
                    setSelectedShapeIds([lastShape.id]);
                    setTool('select');
                }
            }
        }
    }, [shapes, removeShapes, saveHistory, setTool, setSelectedShapeIds, selectionRectRef, stageRef]);
    
    const handleContextMenu = useCallback((e: Konva.KonvaEventObject<PointerEvent>) => e.evt.preventDefault(), []);

    return { handleMouseDown, handleMouseMove, handleMouseUp, handleDragStart, handleDragMove, handleDragEnd, handleDelete, handleCopy, handlePaste, handleCut, handleContextMenu, handleTransformStart, handleTransform, handleTransformEnd };
};
