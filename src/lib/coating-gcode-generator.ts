import { CustomShapeConfig } from '@/types/custom-konva-config';
import {GcodeSettings} from "@/types/gcode";

// Z축을 선택적으로 포함하도록 인터페이스 수정
interface Point {
    x: number;
    y: number;
    z?: number;
}

interface PathSegment {
    type: 'safe' | 'unsafe';
    start: number;
    end: number;
    cause?: CustomShapeConfig;
}

/**
 * G-code 생성과 상태 추적을 전담하는 클래스
 */
class GCodeEmitter {
    private gcode: string = '';
    private lastPosition: Point = { x: 0, y: 0, z: 0 };
    private readonly settings: GcodeSettings;

    constructor(settings: GcodeSettings) {
        this.settings = settings;
        // this.initialize();
    }

    addLine(line: string) {
        this.gcode += line + '\n';
    }

    // private initialize() {
    //     this.addLine(';(G-code generated by Custom Coater)');
    //     this.addLine(`;(Settings: ${JSON.stringify(this.settings)})`);
    //     this.addLine('G90 ; Absolute positioning');
    //     this.addLine('G21 ; Millimeter units');
    //     this.lastPosition = { x: 0, y: 0, z: 0 };
    // }
    // public finalize() {
    //     this.setZ(this.settings.safeHeight);
    //     this.travelTo(0, 0);
    //     this.addLine('M2 ; End of program');
    // }

    private moveTo(x: number, y: number, z: number | undefined, speed: number, isRapid: boolean) {
        if (
            Math.abs(this.lastPosition.x - x) < 0.01 &&
            Math.abs(this.lastPosition.y - y) < 0.01 &&
            (z === undefined || z === null || Math.abs(this.lastPosition.z! - z) < 0.01)
        ) {
            return;
        }
        const command = isRapid ? 'G0' : 'G1';
        this.addLine(`${command} F${speed} X${x.toFixed(3)} Y${y.toFixed(3)}${z !== undefined && z !== null ? ` Z${z.toFixed(3)}` : ''}`);
        this.lastPosition = { x, y, z: z ?? this.lastPosition.z };
    }

    public travelTo(x: number, y: number, z?: number) {
        this.moveTo(x, y, z, this.settings.moveSpeed, true);
    }

    public coatTo(x: number, y: number) {
        this.moveTo(x, y, this.lastPosition.z, this.settings.coatingSpeed, false);
    }

    // [신규] 'skip' 동작을 위한, 노즐이 꺼진 상태의 G1 이동
    public travelAtCoatingHeight(x: number, y: number) {
        this.moveTo(x, y, this.settings.coatingHeight, this.settings.moveSpeed, false);
    }

    public setZ(z: number) {
        // Z축만 이동할 경우 X,Y는 현재 위치 그대로 사용
        this.moveTo(this.lastPosition.x, this.lastPosition.y, z, this.settings.moveSpeed, true);
    }

    public nozzleOn() { this.addLine('M503 ; Nozzle ON'); }
    public nozzleOff() { this.addLine('M504 ; Nozzle OFF'); }
    public getCurrentPosition(): Point { return { ...this.lastPosition }; }


    public getGCode(): string { return this.gcode; }
}

/**
 * 경로 계산을 전담하는 클래스
 */
class PathGenerator {
    private readonly settings: GcodeSettings;
    private readonly boundaryShapes: CustomShapeConfig[];
    private readonly maskShapes: CustomShapeConfig[];
    private readonly maskClearance: number;

    constructor(settings: GcodeSettings, shapes: CustomShapeConfig[]) {
        this.settings = settings;
        this.boundaryShapes = shapes.filter((s): s is Extract<CustomShapeConfig, { type: 'image' }> => s.type === 'image');
        this.maskShapes = settings.enableMasking ? shapes.filter((s): s is Exclude<CustomShapeConfig, { type: 'image' }> => s.type !== 'image') : [];
        this.maskClearance = settings.maskingClearance + settings.coatingWidth / 2;
    }

    /**
     * [최종] 하이브리드 경로 생성 워크플로우를 총괄하는 메인 메서드
     */
    public generatePaths(emitter: GCodeEmitter): void {
        emitter.setZ(this.settings.safeHeight);

        // 1단계: 모든 안전 세그먼트 미리 계산
        const allSafeSegments = this.precalculateAllSafeSegments();
        if (allSafeSegments.length === 0) return;

        // 2단계: 세그먼트들을 3x3 격자 구역으로 군집화
        const zones = this.clusterSegmentsIntoZones(allSafeSegments, 3, 3);

        // 3단계: 각 구역을 순회하며 구역 내 최단 경로 생성
        for (let i = 0; i < zones.length; i++) {
            const zone = zones[i];
            if (zone.length === 0) continue;

            emitter.addLine(`;(--- Processing Zone ${i + 1}/${zones.length} ---)`);
            const startPoint = emitter.getCurrentPosition();
            const orderedPath = this.findPathWithinZone(zone, startPoint);

            for (const segment of orderedPath) {
                emitter.travelTo(segment.start.x, segment.start.y);
                emitter.setZ(this.settings.coatingHeight);
                emitter.nozzleOn();
                emitter.coatTo(segment.end.x, segment.end.y);
                emitter.nozzleOff();
                emitter.setZ(this.settings.safeHeight);
            }
        }
    }

    /**
     * 1단계: 작업 영역 전체의 모든 안전 세그먼트를 계산하여 배열로 반환
     */
    private precalculateAllSafeSegments(): { start: Point; end: Point }[] {
        const segments: { start: Point; end: Point }[] = [];
        const directions: ('horizontal' | 'vertical')[] = [];
        if (this.settings.fillPattern === 'horizontal' || this.settings.fillPattern === 'both') directions.push('horizontal');
        if (this.settings.fillPattern === 'vertical' || this.settings.fillPattern === 'both') directions.push('vertical');

        for (const boundary of this.boundaryShapes) {
            const by = boundary.y ??0;
            const bx = boundary.x ?? 0;
            const bw = boundary.width ??0;
            const bh = boundary.height ??0;

            for (const direction of directions) {
                const isHorizontal = direction === 'horizontal';
                const mainAxisStart = isHorizontal ? by: bx;
                const mainAxisEnd = isHorizontal ? by + bh : bx+ bw;

                for (let mainAxis = mainAxisStart; mainAxis <= mainAxisEnd; mainAxis += this.settings.lineSpacing) {
                    const lineSegments = this.getLineSegments(mainAxis, direction, boundary);
                    for (const seg of lineSegments) {
                        if (seg.type === 'safe') {
                            const startPoint = isHorizontal ? { x: seg.start, y: mainAxis } : { x: mainAxis, y: seg.start };
                            const endPoint = isHorizontal ? { x: seg.end, y: mainAxis } : { x: mainAxis, y: seg.end };
                            segments.push({ start: startPoint, end: endPoint });
                        }
                    }
                }
            }
        }
        return segments;
    }

    /**
     * 2단계: 세그먼트들을 격자 기반 구역으로 나눔
     */
    private clusterSegmentsIntoZones(segments: { start: Point; end: Point }[], gridX: number, gridY: number): { start: Point; end: Point }[][] {
        const zones: { start: Point; end: Point }[][] = Array(gridX * gridY).fill(0).map(() => []);
        const { width, height } = this.settings.workArea;
        const zoneWidth = width / gridX;
        const zoneHeight = height / gridY;

        for (const segment of segments) {
            const midPointX = (segment.start.x + segment.end.x) / 2;
            const midPointY = (segment.start.y + segment.end.y) / 2;
            const zoneCol = Math.floor(midPointX / zoneWidth);
            const zoneRow = Math.floor(midPointY / zoneHeight);
            const zoneIndex = Math.min(zoneRow * gridX + zoneCol, zones.length - 1);
            zones[zoneIndex].push(segment);
        }
        return zones;
    }

    /**
     * 3단계: 단일 구역 내에서 '최근접 이웃' 알고리즘으로 경로 순서를 결정
     */
    private findPathWithinZone(zone: { start: Point; end: Point }[], startPoint: Point): { start: Point; end: Point }[] {
        if (zone.length === 0) return [];

        const remaining = new Set(zone);
        const orderedPath: { start: Point; end: Point }[] = [];
        let currentLocation = startPoint;

        while (remaining.size > 0) {
            let closestSegment: { start: Point; end: Point } | null = null;
            let closestDistance = Infinity;
            let reversed = false;

            // 남아있는 모든 세그먼트의 시작점과 끝점을 대상으로 가장 가까운 지점 탐색
            for (const segment of remaining) {
                const distToStart = Math.hypot(currentLocation.x - segment.start.x, currentLocation.y - segment.start.y);
                const distToEnd = Math.hypot(currentLocation.x - segment.end.x, currentLocation.y - segment.end.y);

                if (distToStart < closestDistance) {
                    closestDistance = distToStart;
                    closestSegment = segment;
                    reversed = false;
                }
                if (distToEnd < closestDistance) {
                    closestDistance = distToEnd;
                    closestSegment = segment;
                    reversed = true;
                }
            }

            if (closestSegment) {
                if (reversed) { // 끝점이 더 가까웠으면 세그먼트 방향을 뒤집어서 경로에 추가
                    orderedPath.push({ start: closestSegment.end, end: closestSegment.start });
                    currentLocation = closestSegment.start;
                } else {
                    orderedPath.push(closestSegment);
                    currentLocation = closestSegment.end;
                }
                remaining.delete(closestSegment);
            }
        }
        return orderedPath;
    }

    private getLineSegments(mainAxis: number, direction: 'horizontal' | 'vertical', boundary: CustomShapeConfig): PathSegment[] {
        const bx = boundary.x ??0;
        const by = boundary.y ??0;
        const bw = boundary.width ??0;
        const bh = boundary.height ??0;

        const { workArea } = this.settings;
        const isHorizontal = direction === 'horizontal';
        const lineStart = Math.max(isHorizontal ? bx : by, 0);
        const lineEnd = Math.min(
            isHorizontal ? bx + bw : by + bh,
            isHorizontal ? workArea.width : workArea.height
        );
        if (lineStart >= lineEnd) return [];
        if (!this.settings.enableMasking || this.maskShapes.length === 0) {
            return [{ type: 'safe', start: lineStart, end: lineEnd }];
        }
        const unsafeIntervals: { start: number; end: number; cause: CustomShapeConfig }[] = [];
        for (const mask of this.maskShapes) {
            const mx = mask.x ??0;
            const my = mask.y ??0;
            const mw = mask.width ??0;
            const mh = mask.height ??0;

            let intersection: { start: number; end: number } | null = null;
            if (mask.type === 'circle') {
                const centerCross = isHorizontal ? mx : my;
                const centerMain = isHorizontal ? my : mx;
                const deltaMain = Math.abs(mainAxis - centerMain);
                if (deltaMain <= mask.radius + this.maskClearance) {
                    const deltaCross = Math.sqrt(Math.pow(mask.radius + this.maskClearance, 2) - Math.pow(deltaMain, 2));
                    intersection = { start: centerCross - deltaCross, end: centerCross + deltaCross };
                }
            } else if (mask.type === 'rectangle') {
                const rectMinCross = isHorizontal ? mx : my;
                const rectMaxCross = isHorizontal ? mx + mw : my+ mh;
                const rectMinMain = isHorizontal ? my : mx;
                const rectMaxMain = isHorizontal ? my + mh : mx+ mw;
                if (mainAxis >= rectMinMain - this.maskClearance && mainAxis <= rectMaxMain + this.maskClearance) {
                    intersection = { start: rectMinCross - this.maskClearance, end: rectMaxCross + this.maskClearance };
                }
            }
            if (intersection) unsafeIntervals.push({ ...intersection, cause: mask });
        }
        if (unsafeIntervals.length === 0) return [{ type: 'safe', start: lineStart, end: lineEnd }];
        unsafeIntervals.sort((a, b) => a.start - b.start);
        const mergedUnsafe: { start: number; end: number; cause: CustomShapeConfig }[] = [];
        if (unsafeIntervals.length > 0) {
            let currentMerge = { ...unsafeIntervals[0] };
            for (let i = 1; i < unsafeIntervals.length; i++) {
                const next = unsafeIntervals[i];
                if (next.start < currentMerge.end) {
                    currentMerge.end = Math.max(currentMerge.end, next.end);
                } else {
                    mergedUnsafe.push(currentMerge);
                    currentMerge = { ...next };
                }
            }
            mergedUnsafe.push(currentMerge);
        }
        const allSegments: PathSegment[] = [];
        let cursor = lineStart;
        for (const unsafe of mergedUnsafe) {
            if (cursor < unsafe.start) allSegments.push({ type: 'safe', start: cursor, end: unsafe.start });
            allSegments.push({ type: 'unsafe', start: unsafe.start, end: unsafe.end, cause: unsafe.cause });
            cursor = unsafe.end;
        }
        if (cursor < lineEnd) allSegments.push({ type: 'safe', start: cursor, end: lineEnd });
        return allSegments.map(seg => ({...seg, start: Math.max(lineStart, seg.start), end: Math.min(lineEnd, seg.end)})).filter(seg => seg.end > seg.start);
    }
}

/**
 * 메인 G-code 생성 함수
 */
export async function generateCoatingGCode(shapes: CustomShapeConfig[], settings: GcodeSettings): Promise<string> {
    const emitter = new GCodeEmitter(settings);
    const pathGenerator = new PathGenerator(settings, shapes);
    pathGenerator.generatePaths(emitter);
    // emitter.finalize();
    return emitter.getGCode();
}